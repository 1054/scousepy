# Licensed under an MIT open source license - see LICENSE

"""

SCOUSE - Semi-automated multi-COmponent Universal Spectral-line fitting Engine
Copyright (c) 2016-2018 Jonathan D. Henshaw
CONTACT: henshaw@mpia.de

"""

import numpy as np
import sys

from .io import *

def compute_noise(scouseobject):
    """
    Estimate the typical rms noise across the map

    Parameters
    ----------
    scouseobject : Instance of the scousepy class

    Notes
    -----
    Credit: Manuel Reiner

    """

    import random

    keep = scouseobject.cube.mask.include().any(axis=0)

    finiteidxs = np.array(np.where(keep))
    flatidxs = [np.ravel_multi_index(finiteidxs[:,i], \
                scouseobject.cube.shape[1:]) for i in range(len(finiteidxs[0,:]))]
    random_indices = random.sample(list(flatidxs), k=len(flatidxs))
    locations = np.array(np.unravel_index(random_indices, \
                                                   scouseobject.cube.shape[1:]))

    if len(locations[0,:]) > 500.0:
        stop = 500.0
    else:
        stop = len(locations[0,:])

    rmsList = []
    stopcount = 0
    specidx = 0
    while stopcount < stop:

        _spectrum = scouseobject.cube[:, locations[0, specidx],
                                                    locations[1, specidx]].value
        if not np.any(np.isfinite(_spectrum)):
            continue

        _spectrum = _spectrum[np.isfinite(_spectrum)]

        rmsVal = calc_rms(_spectrum[~np.isnan(_spectrum)])
        rmsList.append(rmsVal)
        stopcount+=1
        specidx+=1

    rms = np.median(rmsList)

    return rms

def calc_rms(spectrum):
    """
    Returns the spectral rms

    Parameters
    ----------
    Spectrum : spectral cube spectrum
        An individual spectrum taken from the spectral cube

    """

    from astropy.stats import median_absolute_deviation

    # Find all negative values
    negative_indices = (spectrum < 0.0)
    spectrum_negative_values = spectrum[negative_indices]
    reflected_noise = np.concatenate((spectrum[negative_indices],
                                               abs(spectrum[negative_indices])))
    # Compute the median absolute deviation
    MAD = median_absolute_deviation(reflected_noise)
    # For pure noise you should have roughly half the spectrum negative. If
    # it isn't then you need to be a bit more conservative
    if len(spectrum_negative_values) < 0.47*len(spectrum):
        maximum_value = 3.5*MAD
    else:
        maximum_value = 4.0*MAD
    noise = spectrum[spectrum < abs(maximum_value)]
    rms = np.sqrt(np.sum(noise**2) / np.size(noise))

    return rms

def map_locations(shape):
    """
    Returns the pixel locations for all pixels in a map

    Parameters
    ----------
    shape : tuple
        (x,y) shape of the map/cube
    """
    _yy,_xx=np.meshgrid(np.arange(shape[0]),np.arange(shape[1]))
    locations=np.array([np.ravel(_xx),np.ravel(_yy)]).T

    return locations

def map_locations_unmasked(mask):
    """
    Returns the pixel locations of the unmasked data in the map

    Parameters
    ----------
    mask : ndarray
        mask mom0 data generated by the coverage
    """
    idx,idy=np.where(mask.T)
    unmaskedlocations=np.vstack((idx,idy)).T
    return unmaskedlocations

def generate_SAAs(scouseobject, coverageobject, verbose=True):
    """
    Generates the spectral averaging areas according to the parameters set in
    the coverage GUI

    Parameters
    ----------
    scouseobject : Instance of the scousepy class
    coverage object : Instance of the ScouseCoverage class

    """

    import matplotlib.patches as patches
    import matplotlib.path as path
    from .model_housing import saa, add_ids
    from .verbose_output import print_to_terminal

    # get the locations of all pixels in the map
    maploc=map_locations((np.shape(coverageobject.moments[6])[0],np.shape(coverageobject.moments[6])[1]))
    # get the locations of the unmasked data
    maploc_unmasked=map_locations_unmasked(coverageobject.moments[6])

    for i, w in enumerate(coverageobject.wsaa, start=0):
        # Create individual dictionaries for each wsaa
        scouseobject.saa_dict[i] = {}
        coverage=coverageobject.coverage[i]

        if verbose:
            progress_bar = print_to_terminal(stage='s1', step='coverage',length=len(coverage[:,0]), var=w)

        for j in range(len(coverage[:,0])):
            # Identify the bottom left corner of the SAA.
            bl=(coverage[j,0]-w/2., coverage[j,1]-w/2.)
            # create a patch and obtain the path
            saapatch=patches.Rectangle(bl,w,w)
            # get the edge points
            verts = saapatch.get_verts()
            # create a path
            saapath = path.Path(verts,closed=True)

            # identify which locations are contained within that path.
            saaspectramask=saapath.contains_points(maploc)
            saaspectra=maploc[(saaspectramask==True)]
            saamask_reshaped=np.reshape(saaspectramask,np.flip(coverageobject.moments[6].shape)).T
            # remove any masked spectra from the SAA
            saamask=saamask_reshaped*coverageobject.moments[6]
            # Generate a masked subcube
            masked_saacube=scouseobject.cube.with_mask(saamask)
            # generate the average spectrum
            saaspectrum=np.nanmean(masked_saacube.filled_data[:], axis=(1,2))

            if coverage[j,2]==1:
                sample=True
            else:
                sample=False

            # generate the SAA
            SAA = saa(np.array([coverage[j,0],coverage[j,1]]), saaspectrum, idx=j, sample=sample, scouse=scouseobject)
            # Add the SAA to the dictionary
            scouseobject.saa_dict[i][j] = SAA

            # get the unmasked positions
            maploc_unmaskedmask=saapath.contains_points(maploc_unmasked)
            saaspectra=np.flip(maploc_unmasked[(maploc_unmaskedmask==True)],axis=1)
            # add these to the SAAs
            add_ids(SAA, saaspectra)

            if verbose:
                progress_bar.update()

        if verbose:
            print('')
            print('')

def get_x_axis(scouseobject, coverageobject):
    """
    Returns x_axis for spectra

    Parameters
    ----------
    scouseobject : Instance of the scousepy class

    """
    x = np.array(scouseobject.cube.spectral_axis.value)

    x = np.array(scouseobject.cube.spectral_axis.value)
    trimids = ((x>=coverageobject.velmin)&(x<=coverageobject.velmin))
    if not any(trimids):
        trimids=np.ones(np.shape(x), dtype=bool)
    xtrim = x[trimids]

    return x, xtrim, trimids

def plot_coverage(scouseobject, coverageobject, dir, filename):
    """
    Plot the SAA boxes

    Parameter
    ---------
    scouseobject : Instance of the scousepy class
    coverage object : Instance of the ScouseCoverage class
    dir : string
        output directory
    filename : string
        output filename

    """
    import matplotlib.pyplot as plt
    import matplotlib.patches as patches

    fig = plt.figure(figsize=(14, 8))
    try:
        from wcsaxes import WCSAxes
        _wcaxes_imported = True
    except ImportError:
        _wcaxes_imported = False
        if coverageobject.moments[0].wcs is not None:
            warnings.warn("`WCSAxes` package required for wcs coordinate display.")

    blank_window_ax=[0.1,0.1,0.8,0.8]
    newaxis=[blank_window_ax[0]+0.03, blank_window_ax[1]+0.03, blank_window_ax[2]-0.06,blank_window_ax[3]-0.045]

    # set up the map window
    if coverageobject.moments[0].wcs is not None and _wcaxes_imported:
        ax_image = WCSAxes(fig, newaxis, wcs=coverageobject.moments[0].wcs, slices=('x','y'))
        map_window = fig.add_axes(ax_image)
        x = map_window.coords[0]
        y = map_window.coords[1]
        x.set_ticklabel(exclude_overlapping=True)
        y.set_ticklabel(rotation=90,verticalalignment='bottom', horizontalalignment='left',exclude_overlapping=True)
    else:
        map_window = fig.add_axes(newaxis)

    vmin=np.nanmin(coverageobject.moments[0].value)-0.05*np.nanmin(coverageobject.moments[0].value)
    vmax=np.nanmax(coverageobject.moments[0].value)+0.05*np.nanmax(coverageobject.moments[0].value)

    im=map_window.imshow(coverageobject.moments[0].value, cmap=plt.cm.binary_r, origin='lower',
                         interpolation='nearest', vmin=vmin,vmax=vmax)

    _colors = ['dodgerblue','indianred','springgreen','yellow','magenta','cyan']

    # Cycle through and plot the coverage
    for i in range(len(coverageobject.wsaa)):
        c=_colors[i]
        mypath=coverageobject.coverage_path[i]
        # create the patch
        saapatch = patches.PathPatch(mypath,alpha=0.4, facecolor=c, edgecolor='black')
        map_window.add_patch(saapatch)

    plt.savefig(dir+'/'+filename+'_coverage.pdf', dpi=300,bbox_inches='tight')
